<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Recursion</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
<iframe width="100%" height="156px" src="header.html"></iframe>
<iframe width="100%" height="62px" src="lessons.html"></iframe>
<p></p>
<h1> Recursion </h1>
<img src="recursion.png" class="center" alt="">
<p></p>
<h2> What is Recursion? </h2>
<p> The definition of recursion is "the repeated application of a recursive procedure (a procedure that calls itself)".
    Recursion is a way of solving a problem which involves some sort of repetition. </p>
<p> A recursive method has two parts, a <b>base case</b> and a <b>recursive case</b>. The recursive case is what is
    executed by default. It must also call itself in some way. The recursive case usually makes the problem smaller in
    some way. The base case is executed when a specific condition is met. It must also stop the recursion by not calling
    itself. </p>
<p> In a recursive method, returning values is very important. Conventionally, a recursive method will be a return
    method. The recursive case's return statement will always include calling itself to continue the recursion, and the
    base case's return statement will not. Return statements allows for tail recursion to be done, which adds something
    to the return value for every recursive call. </p>
<pre><code> public int factorsOfTwo(int n) {
     if (n % 2 == 1) {
         return 0;
     }
     return factorsOfTwo(n % 2) + 1;
 }
</code></pre>
<p> In the above example, every time the integer n can be divided by two, the number returned is increased by one. This
    will successfully return the amount of factors of two in a number. </p>
<p> In a recursive method, method parameters are also very important. This allows for values to be passed along as the
    recursion continues, which is shown in the above method. </p>
<h2> Recursion versus Iteration </h2>
<p> Recursion and <b>iteration</b> are very similar and can often be used in place of each other. Making the choice
    between either way of solving a problem depends on your limitations, and this is when knowing their advantages is
    essential for making the correct choice at times. </p>
<h3> Advantages of Recursion </h3>
<p> A recursive solution is often a much more simple and graceful solution than an iterative solution. Most problems
    that can be solved with recursion are best solved with recursion, because it is usually easier to follow than an
    iterative solution. </p>
<h3> Advantages of Iteration </h3>
<p> An iterative solution is often more efficient than a recursive one. Calling a function is much more
    performance-heavy than using a loop. It takes more time and each call will take up memory on the stack and cumulate
    depending on the depth of the recursion. If the recursion goes too deep and many resources are being used, a
    StackOverflowError will be thrown. With iteration, the stack does not have to keep track of what happened in the
    previous iterations, so less memory is used. </p>
<p> Below is an example of my implementation of a recursive DFS (Depth-First Search) used to traverse a 5 by 5 maze
    consisting of 0s (paths) and 1s (walls). Two helper methods are used along with the DFS. For this task, no loops
    were allowed. </p>
<pre style="height: 480px"><code>  /**
   * Looks for a path to an exit starting at the first row and ending at the last row of the maze.
   *
   * @param maze - a 2d array consisting of paths (0) and walls (1).
   * @return true iff a path from an entrance to an exit has been found
   */
  private static boolean traverseMaze(int[][] maze) {
    boolean[][] visited = new boolean[maze.length][maze.length];
    return dfs(maze, visited, 0, 0) || dfs(maze, visited, 0, 1) || dfs(maze, visited, 0, 2)
        || dfs(maze, visited, 0, 3) || dfs(maze, visited, 0, 4);
  }

  /**
   * Checks if the coordinates can be searched.
   *
   * @param maze - the maze to search
   * @param visited - a 2d array showing which indices have already been visited (to avoid infinite
   *        loops)
   * @param row - the row that is being searched
   * @param col - the column that is being searched
   * @return true if the coordinates are within bounds of the maze and have not been visited and are
   *         traversable (not a wall).
   */
  private static boolean isValid(int[][] maze, boolean[][] visited, int row, int col) {
    return row >= 0 && row < maze.length && col >= 0 && col < maze.length && !visited[row][col]
        && maze[row][col] == 0;
  }

  /**
   * Performs a depth-first search starting at the index [row, col] in the maze.
   *
   * @param maze - the maze to search
   * @param visited - a 2d array showing which indices have already been visited (to avoid infinite
   *        loops)
   * @param row - the row that is being searched
   * @param col - the column that is being searched
   * @return true iff the exit has been found
   */
  private static boolean dfs(int[][] maze, boolean[][] visited, int row, int col) {
    if (!isValid(maze, visited, row, col)) {
      return false;
    }
    visited[row][col] = true;
    if (row == maze.length - 1) {
      return true;
    }
    return dfs(maze, visited, row - 1, col) || dfs(maze, visited, row + 1, col)
        || dfs(maze, visited, row, col - 1) || dfs(maze, visited, row, col + 1);
  }
</code></pre>
<h2> Important Terms </h2>
<table>
    <tr>
        <th><u>Keyword</u></th>
        <th><u>Definition</u></th>
    </tr>
    <tr>
        <td>Base Case</td>
        <td>The condition in which the recursion of a function stops</td>
    </tr>
    <tr>
        <td>Return Case</td>
        <td>The condition in which the recursion of a function continues</td>
    </tr>
    <tr>
        <td>Iteration</td>
        <td>The use of loops to repeat a task (as opposed to recursive function calls)</td>
    </tr>
</table>
<br><br><br><br><br><br>
</body>
</html>
